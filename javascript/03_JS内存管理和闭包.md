# JS内存管理和闭包

## 一、内存管理

### 1.1  认识内存管理

不管什么样的编程语言，在**代码的执行过程中都是需要给它分配内存**的，不同的是**某些编程语言**需要我们**自己手动** 

**的管理内存**，**某些编程语言**会可以**自动帮助我们管理内存**： 

不管以什么样的方式来管理内存，**内存的管理都会有如下的生命周期**： 

第一步：分配申请你需要的内存（申请）

第二步：使用分配的内存（存放一些东西，比如对象等）

第三步：不需要使用时，对其进行释放

**不同的编程语言对于第一步和第三步会有不同的实现：**

**手动管理内存**：比如C、C++，包括早期的OC，都是需要手动来管理内存的申请和释放的（malloc和free函 

数）

**自动管理内存**：比如Java、JavaScript、Python、Swift、Dart等，它们有自动帮助我们管理内存

## 二、JS的内存管理

### 2.1    JS的内存分配

JS对于<span style="color:red">基本数据类型内存的分配</span>会在执行时，直接在栈空间进行分配

JS对于<span style="color:red">复杂数据类型内存的分配</span>会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用

![](E:\notes\imgs\javascript\JS内存分配.png)

## 三、JS的垃圾回收

### 3.1  JS垃圾回收机制

因为**内存的大小是有限的**，所以当**内存不再需要的时候**，我们需要对其进行**释放**，以便腾出更多的**内存空间**。

在**手动管理内存的语言**中，我们需要通过**一些方式自己来释放不再需要的内存，比如free函数**

但是这种管理的方式其实<span style='color:red'>非常的低效</span>，影响我们编写<span style='color:red'>编写逻辑的代码的效率</span>,并且这种方式对开发者的要求也很高，并且一不小心就会产生<span style="color:red">内存泄露</span>

大部分**现代的编程语言都有自己的垃圾回收机制**：

垃圾回收英文<span style='color:red'>Garbage Collection, (即：GC)</span>

对于<span style='color:red'>那些不再使用的对象</span>，我们称之为**垃圾**，需要被**回收**，以便释放更多的内存空间。

我们的语言运行环境，比如Java的运行环境JVM，JavaScript的运行环境js引擎都会有内存 **<span style='color:red'>垃圾回收器</span>**，也被称为<span style='color:red'>GC</span>

那么**GC怎么知道哪些对象是不再使用的呢**？

这里就需要<span style='color:red'>GC的算法</span>了

## 四、常见的GC算法

### 4.1  引用计数

当一个对象有一个引用指向它时，这个对象的引用就**+1**，当这个对象的引用为**0**时，这个对象就会被销毁。但是这样有一个**弊端**，就是 会造成**循环引用**

![](E:\notes\imgs\javascript\引用计数的循环引用.png)

### 4.2  标记清除

这个算法是设置一个**根对象**（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对 

于哪些没有引用到的对象，就认为是不可用的对象。这个算法可以很好的解决循环引用的问题

![](E:\notes\imgs\javascript\标记清除算法.png)

JS引擎比较广泛的采用的就是标记清除算法，当然类似于V8引擎为了进行更好的优化，它在算法的实现细节上也会结合 

一些其他的算法

## 五、闭包

### 5.1  让人迷惑的闭包

闭包是JavaScript中一个非常容易让人迷惑的知识点

![](E:\notes\imgs\javascript\让人迷惑的闭包.png)

### 5.2 JS中函数是一等公民

在JavaScript中，函数是非常重要的，并且是一等公民，那么就意味着函数的使用是非常灵活的： 

函数可以作为另外一个函数的参数，也可以作为另外一个函数的返回值来使用；  自己编写高阶函数 ，使用内置的高阶函数

### 5.3 Js中闭包的定义

#### 5.3.1 计算机科学中的定义

在计算机科学中对闭包的定义（维基百科）： 

闭包（英语：Closure），又称**词法闭包**（Lexical Closure）或**函数闭包**（function closures）

 是在支持 **头等函数** 的编程语言中，实现词法绑定的一种技术

 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）

 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 **自由变量** 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行

闭包的概念出现于60年代，最早实现闭包的程序是 Scheme，那么我们就可以理解为什么JavaScript中有闭包， 因为JavaScript中有大量的设计是来源于Scheme的

#### 5.3.2 MDN对JavaScript闭包的定义

一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）

也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域 

在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来

#### 5.3.3 我的理解和总结： 

一个普通的函数function，如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包

 从广义的角度来说：JavaScript中的函数都是闭包

从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包

### 5.4  闭包的访问过程

![](E:\notes\imgs\javascript\闭包代码.png)

![](E:\notes\imgs\javascript\闭包过程.png)

### 5.5 闭包的执行过程

这个时候makeAdder函数执行完毕，正常情况下我们的AO对象会被释放，但是因为在0xb00的函数中有作用域引用指向了这个AO对象，所以它不会被释放掉

![](E:\notes\imgs\javascript\闭包的引用指向.png)

### 5.6 闭包的内存泄漏

上面的案例中，如果后续我们不再使用add10函数了，那么该函数对象应该要被销毁掉，并且其引用着的父 

作用域AO也应该被销毁掉，但是目前因为在全局作用域下add10变量对0xb00的函数对象有引用，而0xb00的作用域中AO（0x200）有引 用，所以最终会造成这些内存都是无法被释放的

所以我们经常说的闭包会造成内存泄露，其实就是刚才的引用链中的所有对象都是无法释放的； 

那么，怎么解决这个问题呢？ 

因为当将add10设置为null时，就不再对函数对象0xb00有引用，那么对应的AO对象0x200也就不可达了，在GC的下一次检测中，它们就会被销毁掉

![](E:\notes\imgs\javascript\闭包解决内存泄漏.png)

### 5.7  闭包的内存泄漏测试

![](E:\notes\imgs\javascript\闭包的内存泄漏测试.png)

![](E:\notes\imgs\javascript\闭包内存泄漏测试状况.png)

### 5.8 AO不使用的属性

AO对象不会被销毁时，是否里面的所有属性都不会被释放？ 

下面这段代码中name属于闭包的父作用域里面的变量，我们知道形成闭包之后count一定不会被销毁掉，那么name是否会被销毁掉呢？ 

这里我打上了断点，我们可以在浏览器上看看结果：

![](E:\notes\imgs\javascript\AO不使用的属性代码.png)

![](E:\notes\imgs\javascript\AO不使用的属性反馈.png)