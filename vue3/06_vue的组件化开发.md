# 组件化开发

## 一、**人处理问题的方式**

**人面对复杂问题的处理方式：** 

任何一个人处理信息的逻辑能力都是有限的 ，所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。 但是，我们人有一种天生的能力，就是将问题进行拆解。 如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。

![](../imgs/vue3/%E4%BA%BA%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E5%BC%8F.png)

## 二、**认识组件化开发**

**组件化也是类似的思想：** 

如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展； 但如果，我们讲一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了； 如果我们将一个个功能块拆分后，就可以像搭建积木一下来搭建我们的项目

![](../imgs/vue3/%E8%AE%A4%E8%AF%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.png)

## 三、**组件化开发**

**现在可以说整个的大前端开发都是组件化的天下**，无论从三大框架（Vue、React、Angular），还是跨平台方案的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想。 所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的。 我们需要通过组件化的思想来思考整个应用程序： 

我们将**一个完整的页面分成很多个组件**； **每个组件都用于实现页面的一个功能块**； 而**每一个组件又可以进行细分**； 而**组件本身又可以在多个地方进行复用**

## 四、**Vue的组件化**

**组件化是Vue、React、Angular的核心思想**

前面我们的createApp函数传入了一个对象App，这个**对象其实本质上就是一个组件**，也是我们**应用程序的根组件**；组件化提供了一种抽象，让我们可以开发出一个个**独立可复用的小组件**来构造我们的应用； **任何的应用都会被抽象成一颗组件树**

![](../imgs/vue3/vue%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96.png)

### 4.1 **注册组件的方式**

如果我们现在有一部分**内容（模板、逻辑等）**，我们希望将这部分内容抽取到一个**独立的组件**中去维护，这个时候**如何注册一个组件**呢？

**注册组件分成两种：**

**<span style='color:red'>全局组件</span>**：在任何其他的组件中都可以使用的组件

**<span style='color:red'>局部组件</span>**：只有在注册的组件中才能使用的组件

#### 4.1.1 **注册全局组件**

全局组件需要使用我们全局创建的**app来注册组件**

通过**component**方法传入**组件名称、组件对象**即可注册一个全局组件了，之后，我们可以在**App组件的template**中直接使用这个全局组件

![](../imgs/vue3/%E6%B3%A8%E5%86%8C%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%EF%BC%881%EF%BC%89.png)

![](../imgs/vue3/%E6%B3%A8%E5%86%8C%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%EF%BC%882%EF%BC%89.png)

**全局组件的逻辑**

**当然，我们组件本身也可以有自己的代码逻辑：**比如自己的data、computed、methods等等

```javascript
// 注册全局组件（使用app）
app.component('my-cpn', {
  template: '#my-cpn',
  data() {
     return {
        title: '我是标题',
        message: '我是内容'                           
     },
   computed: {
      getTitle: {
          return this.title
      }
   },
   metnods: {
      btnClick() {
         console.log('btnClick')
      }
   }
  }
})
```

**组件的名称**

在通过app.component注册一个组件的时候，**第一个参数是组件的名称**，定义组件名的方式有两种：

**方式一：使用kebab-case（短横线分割符）** 

当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也**必须在引用这个自定义元素时使用 kebab-case**， 

例如 <my-component-name>

**方式二：使用PascalCase（驼峰标识符）**

当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时**两种命名法都可以使用**。也 

就是说 <my-component-name> 和 <MyComponentName> 都是可接受的

#### 4.1.2 **注册局部组件**

全局组件往往是在应用程序一开始就会**全局组件**完成，那么就意味着如果**某些组件我们并没有用到**，**也会一起被注册**：

比如我们注册了三个全局组件：ComponentA、ComponentB、ComponentC； 在开发中我们只使用了ComponentA、ComponentB，如果ComponentC没有用到但是我们依然在全局进行了注册，那么就意味着类似于webpack这种打包工具在打包我们的项目时，我们依然会对其进行打包； 这样最终打包出的JavaScript包就会有关于ComponentC的内容，用户在下载对应的JavaScript时也会增加包的大小 

**所以在开发中我们通常使用组件的时候采用的都是局部注册：** 

局部注册是在我们需要使用到的组件中，通过components属性选项来进行注册； 比如之前的App组件中，我们有data、computed、methods等选项了，事实上还可以有一个**components**选项； 该**components选项对应的是一个对象**，对象中的**键值对是组件的名称: 组件对象**

![](../imgs/vue3/%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6.png)

## 五、**Vue的开发模式**

目前我们使用vue的过程都是**在html文件中**，通过template编写自己的模板、脚本逻辑、样式等。 **但是随着项目越来越复杂，我们会采用组件化的方式来进行开发：** 

这就意味着每个组件都会有自己的模板、脚本逻辑、样式等； 当然我们依然可以把它们抽离到单独的js、css文件中，但是它们还是会分离开来； 也包括我们的script是在一个全局的作用域下，很容易出现命名冲突的问题； 并且我们的代码为了适配一些浏览器，必须使用ES5的语法； 在我们编写代码完成之后，依然需要通过工具对代码进行构建、编码； 所以在真实开发中，我们可以通过一个后缀名为 .vue 的**single-file components (单文件组件)** 来解决，并且可以使用**webpack**或者**vite**或者**rollup**等构建工具来对其进行处理

## 六、**单文件的特点**

**在这个组件中我们可以获得非常多的特性：** 

代码的高亮

ES6、CommonJS的模块化能力

组件作用域的CSS

可以使用预处理器来构建更加丰富的组件，比如TypeScript、Babel、Less、Sass等

![](../imgs/vue3/%E5%8D%95%E6%96%87%E4%BB%B6.png)

## 七、**如何支持SFC**

如果我们想要使用这一的SFC的.vue文件，比较**常见的是两种方式**： 

方式一：使用**Vue CLI来创建项目**，项目会默认帮助我们配置好所有的配置选项，可以在其中直接使用.vue文件

方式二：自己使用**webpack或rollup或vite这类打包工具**，对其进行打包处理

我们最终，无论是后期我们做项目，还是在公司进行开发，通常都会采用Vue CLI的方式来完成。 

